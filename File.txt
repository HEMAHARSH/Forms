import yaml
import json
import os
from scripts.dbchecks import handle_db_check

OUTPUT_FILE = "output.json"
REPORT_FILE = "report.json"

def load_yaml(path):
    try:
        with open(path, "r") as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        print("The YAML file was not found.")
        return None

def dispatch_check(check):
    check_type = check.get("type")
    check_handlers = {
        "DBCheck": handle_db_check,
    }
    handler = check_handlers.get(check_type)
    if handler:
        handler(check)
    else:
        print(f"Unsupported check type: {check_type}")

def generate_json_report():
    if not os.path.exists(OUTPUT_FILE):
        print("No output.json file found.")
        return

    with open(OUTPUT_FILE, "r") as f:
        try:
            results = json.load(f)
        except json.JSONDecodeError:
            print("Invalid JSON format in output.json.")
            return

    summary = []
    for check in results:
        for res in check.get("results", []):
            summary.append({
                "type": check.get("type"),
                "db_type": check.get("db_type", "unknown"),
                "query": res.get("query", "N/A"),
                "status": res.get("status"),
                "message": res.get("message")
            })

    with open(REPORT_FILE, "w") as f:
        json.dump(summary, f, indent=4)
    print(f"Report saved to {REPORT_FILE}")

def main():
    config = load_yaml("config.yaml")
    if not config:
        return

    app_config = config.get("application", {})
    checks = app_config.get("checks", [])

    for check in checks:
        dispatch_check(check)

    report_cfg = app_config.get("report", {})
    if report_cfg.get("generateReport", False) and report_cfg.get("format", "").lower() == "json":
        generate_json_report()

if __name__ == "__main__":
    main()



import os
import json
import psycopg2
import cx_Oracle
from lookupPlugins.getCred import Lookup

OUTPUT_FILE = "output.json"

class DBConnector:
    @staticmethod
    def connect_postgresql(config):
        username = DBConnector.fetch_credential(config, "username")
        password = DBConnector.fetch_credential(config, "password")
        return psycopg2.connect(
            host=config['db_host'],
            database=config['db_name'],
            user=username,
            password=password
        )

    @staticmethod
    def connect_oracle(config):
        username = DBConnector.fetch_credential(config, "username")
        password = DBConnector.fetch_credential(config, "password")
        dsn = f"{config['db_host']}/{config['db_name']}"
        return cx_Oracle.connect(username, password, dsn)

    @staticmethod
    def fetch_credential(config, field):
        credsdata = config.get("credsdata")
        if credsdata and all(k in credsdata for k in [
            'credential', 'safe', 'appid', 'cyberark_ca',
            'cyberark_cred', 'cyberark_key']):
            return Lookup.getCreds(
                field,
                credsdata['credential'],
                credsdata['safe'],
                credsdata['appid'],
                credsdata['cyberark_ca'],
                credsdata['cyberark_cred'],
                credsdata['cyberark_key']
            )
        return None

class DBCheck:
    def __init__(self, config):
        self.config = config
        self.conn = None
        self.cur = None
        self.db_connect_dispatcher = {
            'postgresql': DBConnector.connect_postgresql,
            'oracle': DBConnector.connect_oracle
        }

    def connect(self):
        db_type = self.config.get('db_type', '').lower()
        connect_func = self.db_connect_dispatcher.get(db_type)
        if not connect_func:
            print(f"Unsupported database type: {db_type}")
            return

        try:
            self.conn = connect_func(self.config)
            self.cur = self.conn.cursor()
        except Exception as e:
            print(f"DB connection failed for {db_type}: {e}")
            self.conn = None
            self.cur = None

    def execute_query(self, query):
        try:
            self.cur.execute(query)
            return self.cur.fetchall()
        except Exception as e:
            print(f"Error executing query: {e}")
            return None

    def close_connection(self):
        if self.cur:
            self.cur.close()
        if self.conn:
            self.conn.close()

class JsonOutput:
    def __init__(self):
        self.operator_map = {
            ">": self._greater,
            "<": self._lesser,
            "==": self._equal,
            ">=": self._greater_equal,
            "<=": self._lesser_equal
        }

    def _greater(self, output, value): return output > value, f"{output} > {value}"
    def _lesser(self, output, value): return output < value, f"{output} < {value}"
    def _equal(self, output, value): return output == value, f"{output} == {value}"
    def _greater_equal(self, output, value): return output >= value, f"{output} >= {value}"
    def _lesser_equal(self, output, value): return output <= value, f"{output} <= {value}"

    def compare_and_generate(self, output, count_expr):
        if count_expr is None:
            return {
                "output": output,
                "status": "Success",
                "message": "No count condition provided"
            }

        parts = count_expr.split()
        if len(parts) != 2:
            return {
                "output": output,
                "status": "Failure",
                "message": "Invalid count expression format"
            }

        operator, value_str = parts
        try:
            value = int(value_str)
        except ValueError:
            return {
                "output": output,
                "status": "Failure",
                "message": f"Invalid value for comparison: {value_str}"
            }

        func = self.operator_map.get(operator)
        if not func:
            return {
                "output": output,
                "status": "Failure",
                "message": f"Unsupported operator: {operator}"
            }

        success, message = func(output, value)
        return {
            "output": output,
            "status": "Success" if success else "Failure",
            "message": message
        }

def handle_db_check(config):
    if os.path.exists(OUTPUT_FILE):
        with open(OUTPUT_FILE, "r") as f:
            try:
                all_results = json.load(f)
            except json.JSONDecodeError:
                all_results = []
    else:
        all_results = []

    db_results = []
    db_type = config.get("db_type", "unknown")

    db_check = DBCheck(config)
    db_check.connect()

    if db_check.cur is None:
        db_results.append({
            "status": "Failure",
            "message": f"Skipping DB [{db_type}] due to failed connection"
        })
    else:
        queries = config.get("queries", [])
        if not isinstance(queries, list):
            db_results.append({"status": "Failure", "message": "Invalid queries configuration"})
        else:
            for query_config in queries:
                if not isinstance(query_config, dict) or 'query' not in query_config:
                    db_results.append({"status": "Failure", "message": "Invalid query configuration"})
                    continue

                query = query_config['query']
                condition = query_config.get('condition')

                try:
                    rows = db_check.execute_query(query)
                    if rows:
                        output = rows[0][0]
                        result = JsonOutput().compare_and_generate(output, condition)
                    else:
                        result = {"status": "Failure", "message": "Query returned no data"}

                    result["query"] = query
                    db_results.append(result)

                except Exception as e:
                    db_results.append({
                        "status": "Failure",
                        "message": f"Error executing query: {str(e)}",
                        "query": query
                    })

        db_check.close_connection()

    all_results.append({
        "type": "DBCheck",
        "db_type": db_type,
        "results": db_results
    })

    with open(OUTPUT_FILE, "w") as f:
        json.dump(all_results, f, indent=4)
