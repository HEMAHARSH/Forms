import os
import json
import psycopg2
import cx_Oracle
import xml.etree.ElementTree as ET
from lookupPlugins.getCred import Lookup

class DBConnector:
    @staticmethod
    def connect_postgresql(config):
        username = DBConnector.fetch_credential(config, "username")
        password = DBConnector.fetch_credential(config, "password")
        return psycopg2.connect(
            host=config['db_host'],
            database=config['db_name'],
            user=username,
            password=password
        )

    @staticmethod
    def connect_oracle(config):
        username = DBConnector.fetch_credential(config, "username")
        password = DBConnector.fetch_credential(config, "password")
        dsn = f"{config['db_host']}/{config['db_name']}"
        return cx_Oracle.connect(username, password, dsn)

    @staticmethod
    def fetch_credential(config, field):
        credsdata = config.get("credsdata")
        if credsdata and all(k in credsdata for k in ['credential', 'safe', 'appid', 'cyberark_ca', 'cyberark_cred', 'cyberark_key']):
            return Lookup.getCreds(
                field,
                credsdata['credential'],
                credsdata['safe'],
                credsdata['appid'],
                credsdata['cyberark_ca'],
                credsdata['cyberark_cred'],
                credsdata['cyberark_key']
            ).decode()
        return None


class DBCheck:
    def __init__(self, config):
        self.config = config
        self.conn = None
        self.cur = None
        self.db_connect_dispatcher = {
            'postgresql': DBConnector.connect_postgresql,
            'oracle': DBConnector.connect_oracle
        }

    def connect(self):
        db_type = self.config.get('db_type', '').lower()
        connect_func = self.db_connect_dispatcher.get(db_type)
        if not connect_func:
            print(f"Unsupported database type: {db_type}")
            return
        try:
            self.conn = connect_func(self.config)
            self.cur = self.conn.cursor()
        except Exception as e:
            print(f"DB connection failed for {db_type}: {e}")
            self.conn = None
            self.cur = None

    def execute_query(self, query):
        try:
            self.cur.execute(query)
            return self.cur.fetchall()
        except Exception as e:
            print(f"Error executing query: {e}")
            return None

    def close_connection(self):
        if self.cur:
            self.cur.close()
        if self.conn:
            self.conn.close()


class CompareOutput:
    def __init__(self):
        self.operator_map = {
            ">": self.greater,
            "<": self.lesser,
            "==": self.equal,
            ">=": self.greater_equal,
            "<=": self.lesser_equal
        }

    def greater(self, output, value):
        return output > value, f"Database row count is {output} and greater than {value}"

    def lesser(self, output, value):
        return output < value, f"Database row count is {output} and less than {value}"

    def equal(self, output, value):
        return output == value, f"Database row count is {output} and equal to {value}"

    def greater_equal(self, output, value):
        return output >= value, f"Database row count is {output} and greater than or equal to {value}"

    def lesser_equal(self, output, value):
        return output <= value, f"Database row count is {output} and less than or equal to {value}"

    def compare_and_generate(self, output, count_expr):
        if not count_expr:
            return {
                "output": output,
                "status": "Success",
                "message": "No count condition provided"
            }

        parts = count_expr.strip().split()
        if len(parts) != 2:
            return {
                "output": output,
                "status": "Failure",
                "message": "Invalid count expression format"
            }

        operator, value_str = parts
        try:
            value = int(value_str)
        except ValueError:
            return {
                "output": output,
                "status": "Failure",
                "message": f"Invalid value for comparison: {value_str}"
            }

        func = self.operator_map.get(operator)
        if not func:
            return {
                "output": output,
                "status": "Failure",
                "message": f"Unsupported operator: {operator}"
            }

        success, message = func(output, value)
        return {
            "output": output,
            "status": "Success" if success else "Failure",
            "message": message
        }


class Output:
    def generate_json_report(self, all_results, config):
        report = {
            "report": {
                "checks": all_results
            }
        }
        report_file = "report.json"
        with open(report_file, "w") as f:
            json.dump(report, f, indent=4)
        print(f"Report saved to {report_file}")

    def generate_xml_report(self, all_results, config):
        root = ET.Element("report")
        checks = ET.SubElement(root, "checks")
        for result in all_results:
            check = ET.SubElement(checks, "check")
            ET.SubElement(check, "type").text = result.get("type")
            ET.SubElement(check, "db_type").text = result.get("db_type")
            results = ET.SubElement(check, "results")
            for res in result.get("results", []):
                result_element = ET.SubElement(results, "result")
                ET.SubElement(result_element, "query").text = res.get("query")
                ET.SubElement(result_element, "status").text = res.get("status")
                ET.SubElement(result_element, "message").text = res.get("message")
        tree = ET.ElementTree(root)
        report_file = "report.xml"
        tree.write(report_file, encoding="utf-8", xml_declaration=True)
        print(f"Report saved to {report_file}")


def handle_db_check(config):
    db_results = []
    db_type = config.get("db_type")
    db_check = DBCheck(config)
    db_check.connect()

    if db_check.cur is None:
        db_results.append({
            "status": "Failure",
            "message": f"Skipping DB [{db_type}] due to failed connection",
            "db_type": db_type
        })
    else:
        queries = config.get("queries", [])
        if not isinstance(queries, list):
            db_results.append({
                "status": "Failure",
                "message": "Invalid queries configuration",
                "db_type": db_type
            })
        else:
            for query_config in queries:
                if not isinstance(query_config, dict) or 'query' not in query_config:
                    db_results.append({
                        "status": "Failure",
                        "message": "Invalid query configuration",
                        "db_type": db_type
                    })
                    continue
                query = query_config['query']
                condition = query_config.get("condition")
                try:
                    rows = db_check.execute_query(query)
                    if rows:
                        output = rows[0][0]
                        result = CompareOutput().compare_and_generate(output, condition)
                        result["query"] = query
                        result["db_type"] = db_type
                        db_results.append(result)
                    else:
                        db_results.append({
                            "status": "Failure",
                            "message": "Query returned no data",
                            "query": query,
                            "db_type": db_type
                        })
                except Exception as e:
                    db_results.append({
                        "status": "Failure",
                        "message": f"Error executing query: {str(e)}",
                        "query": query,
                        "db_type": db_type
                    })
        db_check.close_connection()

    result_summary = {
        "type": "DBCheck",
        "db_type": db_type,
        "results": db_results
    }

    # Reporting
    app_config = config.get("application", {})
    report_config = app_config.get("report", {})
    report_type = report_config.get("format", "").lower()
    generate_report = report_config.get("generateReport", False)

    output_writer = Output()
    if generate_report:
        if report_type == "xml":
            output_writer.generate_xml_report([result_summary], config)
        else:
            output_writer.generate_json_report([result_summary], config)
    else:
        output_writer.generate_json_report([result_summary], config)

    return result_summary
