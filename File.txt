def handle_db_check(config, report_format="json", generate_report=True):
    db_results = []
    db_type = config.get("db_type")

    db_check = DBCheck(config)
    db_check.connect()

    if db_check.cur is None:
        db_results.append({
            "status": "Failure",
            "message": f"Skipping DB [{db_type}] due to failed connection",
            "db_type": db_type
        })
    else:
        queries = config.get("queries", [])
        for query_config in queries:
            # [validation and execution code same as before...]
            # Collect result as shown earlier
            pass

    db_check.close_connection()

    check_result = {
        "type": "DBCheck",
        "db_type": db_type,
        "results": db_results
    }

    # Store the result for final reporting
    aggregated_results.append(check_result)

    # Only write the report if it's the last one (check at runtime)
    # Use a flag stored on the Output class
    if generate_report:
        Output.defer_report(aggregated_results, config, report_format)

    return check_result


class Output:
    @staticmethod
    def defer_report(results, config, report_format):
        # Use a global flag to check if report already written
        if getattr(Output, "_report_written", False):
            return
        Output._report_written = True

        if report_format == "json":
            Output().generate_json_report(results, config)
        elif report_format == "xml":
            Output().generate_xml_report(results, config)
        else:
            print("Unsupported report format. Defaulting to JSON.")
            Output().generate_json_report(results, config)



handle_db_check(check, report_format=report_format)
